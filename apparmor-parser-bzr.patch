=== added file '.bzrignore'
--- .bzrignore	1970-01-01 00:00:00 +0000
+++ .bzrignore	2010-06-05 01:39:20 +0000
@@ -0,0 +1,25 @@
+parser/po/*.mo
+parser/af_names.h
+parser/cap_names.h
+parser/tst_misc
+parser/tst_regex
+parser/tst_symtab
+parser/tst_variable
+parser/parser_lex.c
+parser/parser_version.h
+parser/parser_yacc.c
+parser/parser_yacc.h
+parser/pod2htm*.tmp
+parser/*.7
+parser/*.5
+parser/*.8
+parser/*.7.html
+parser/*.5.html
+parser/*.8.html
+parser/common
+parser/apparmor_parser
+parser/libapparmor_re/regexp.cc
+parser/techdoc.aux
+parser/techdoc.log
+parser/techdoc.pdf
+parser/techdoc.toc

=== modified file 'libraries/libapparmor/swig/perl/Makefile.am'
--- libraries/libapparmor/swig/perl/Makefile.am	2009-05-12 21:56:56 +0000
+++ libraries/libapparmor/swig/perl/Makefile.am	2010-03-16 22:00:26 +0000
@@ -1,7 +1,8 @@
 EXTRA_DIST =Makefile.PL libapparmor_wrap.c LibAppArmor.pm examples/*.pl
+
+if HAVE_PERL
 noinst_DATA =LibAppArmor.so
 
-if HAVE_PERL
 libapparmor_wrap.c: $(srcdir)/../SWIG/libapparmor.i
 	$(SWIG) -perl -I$(srcdir)/../../src -module LibAppArmor -o $@ $(srcdir)/../SWIG/libapparmor.i
 
@@ -27,4 +28,4 @@
 #rm -f Makefile.perl Makefile.perl.old
 	rm -f *.so # *.o
 
-endif
\ No newline at end of file
+endif

=== modified file 'parser/Makefile'
--- parser/Makefile	2009-11-11 18:58:57 +0000
+++ parser/Makefile	2010-03-16 22:18:55 +0000
@@ -125,9 +125,20 @@
 techdoc.txt: techdoc/index.html
 	w3m -dump $< > $@
 
-all: 	$(TOOLS) $(MANPAGES) ${HTMLMANPAGES} techdoc.pdf
+# targets arranged this way so that people who don't want full docs can
+# pick specific targets they want.
+main: 	$(TOOLS)
 	$(Q)make -C po all
-	$(Q)make -s tests
+
+manpages:	$(MANPAGES)
+
+htmlmanpages:	$(HTMLMANPAGES)
+
+pdf:	techdoc.pdf
+
+docs:	manpages htmlmanpages pdf
+
+all:	main docs tests
 
 apparmor_parser: $(OBJECTS) $(PCREOBJECTS) $(AAREOBJECTS)
 	rm -f ./libstdc++.a
@@ -191,7 +202,7 @@
 af_names.h: /usr/include/bits/socket.h
 	LC_ALL=C sed -n -e '/$(__FILTER)/d' -e "s/^\#define[ \\t]\\+PF_\\([A-Z0-9_]\\+\\)[ \\t]\\+\\([0-9]\\+\\)\\(.*\\)\$$/#ifndef AF_\\1\\n#  define AF_\\1 \\2\\n#endif\\nAA_GEN_NET_ENT(\"\\L\\1\", \\UAF_\\1)\\n/p" $< > $@
 	LC_ALL=C sed -n -e "s/^\#define[ \\t]\\+PF_MAX[ \\t]\\+\\([0-9]\\+\\)[ \\t]\\+.*/#define AA_AF_MAX \\1\n/p" $< >> $@
-	cat $@
+	# cat $@
 
 cap_names.h: /usr/include/linux/capability.h
 	LC_ALL=C sed -n -e "/CAP_EMPTY_SET/d" -e "s/^\#define[ \\t]\\+CAP_\\([A-Z0-9_]\\+\\)[ \\t]\\+\\([0-9xa-f]\\+\\)\\(.*\\)\$$/\{\"\\L\\1\", \\UCAP_\\1\},/p" $< > $@
@@ -214,7 +225,7 @@
 
 .SILENT: tests
 tests: ${TESTS}
-	for test in ${TESTS} ; do echo "*** running $${test}" && ./$${test} $(BUILD_OUTPUT) ; done
+	sh -e -c 'for test in ${TESTS} ; do echo "*** running $${test}" && ./$${test} $(BUILD_OUTPUT) ; done'
 	$(Q)make -s -C tst tests
 
 .SILENT: check

=== modified file 'parser/apparmor_parser.pod'
--- parser/apparmor_parser.pod	2010-01-07 18:03:49 +0000
+++ parser/apparmor_parser.pod	2010-04-03 23:24:06 +0000
@@ -154,6 +154,33 @@
 Given once, only checks the profiles to ensure syntactic correctness.
 Given twice, dumps its interpretation of the profile for checking.
 
+=item -D n, --dump=n
+
+Debug flag for dumping various structures and passes of policy compilation.
+A single dump flag can be specified per --dump option, but the dump flag
+can be passed multiple times.  Note progress flags tend to also imply
+the matching stats flag.
+
+  apparmor_parser --dump=dfa-stats --dump=trans-stats <file>
+
+Use --help=dump to see a full list of which dump flags are supported
+
+=item -O n, --optimize=n
+
+Set the optimization flags used by policy compilation.  A sinlge optimization
+flag can be toggled per -O option, but the optimize flag can be passed
+multiple times.  Turning off some phases of the optimization can make
+it so that policy can't complete compilation due to size constraints
+(it is entirely possible to create a dfa with millions of states that will
+take days or longer to compile).
+
+Note: The parser is set to use a balanced default set of flags, that
+will result in resonable compression but not take excessive amounts
+of time to complete.
+
+Use --help=optimize to see a full list of which optimization flags are
+supported.
+
 =item -h, --help
 
 Give a quick reference guide.

=== modified file 'parser/libapparmor_re/regexp.y'
--- parser/libapparmor_re/regexp.y	2010-02-01 07:21:00 +0000
+++ parser/libapparmor_re/regexp.y	2010-03-13 10:23:23 +0000
@@ -1715,7 +1715,9 @@
 			Trans::iterator j = trans.find(*i);
 			if (j != trans.end())
 				trans.erase(j);
+			State *s = *i;
 			states.erase(*i);
+			delete(s);
 		}
 	}
 

=== modified file 'parser/parser.h'
--- parser/parser.h	2010-02-17 20:21:52 +0000
+++ parser/parser.h	2010-03-12 23:26:32 +0000
@@ -4,6 +4,9 @@
  *   Copyright (c) 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007
  *   NOVELL (All rights reserved)
  *
+ *   Copyright (c) 2010
+ *   Canonical, Ltd. (All rights reserved)
+ *
  *   This program is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
  *   License published by the Free Software Foundation.
@@ -14,7 +17,8 @@
  *   GNU General Public License for more details.
  *
  *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, contact Novell, Inc.
+ *   along with this program; if not, contact Novell, Inc. or Canonical
+ *   Ltd.
  */
 
 #include <netinet/in.h>
@@ -280,12 +284,16 @@
 extern void free_cod_entries(struct cod_entry *list);
 
 /* parser_symtab.c */
+struct set_value {;
+	char *val;
+	struct set_value *next;
+};
 extern int add_boolean_var(const char *var, int boolean);
 extern int get_boolean_var(const char *var);
 extern int new_set_var(const char *var, const char *value);
 extern int add_set_value(const char *var, const char *value);
-extern void *get_set_var(const char *var);
-extern char *get_next_set_value(void **context);
+extern struct set_value *get_set_var(const char *var);
+extern char *get_next_set_value(struct set_value **context);
 extern void dump_symtab(void);
 extern void dump_expanded_symtab(void);
 void free_symtabs(void);
@@ -312,7 +320,7 @@
 extern void add_hat_to_policy(struct codomain *policy, struct codomain *hat);
 extern void add_entry_to_policy(struct codomain *policy, struct cod_entry *entry);
 extern void post_process_nt_entries(struct codomain *cod);
-extern int post_process_policy(void);
+extern int post_process_policy(int debug_only);
 extern int process_hat_regex(struct codomain *cod);
 extern int process_hat_variables(struct codomain *cod);
 extern int post_merge_rules(void);

=== modified file 'parser/parser_include.c'
--- parser/parser_include.c	2009-07-24 12:18:12 +0000
+++ parser/parser_include.c	2010-06-05 01:57:01 +0000
@@ -1,8 +1,8 @@
-/* $Id$ */
-
 /*
  *   Copyright (c) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
  *   NOVELL (All rights reserved)
+ *   Copyright (c) 2010
+ *   Canonical, Ltd.
  *
  *   This program is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
@@ -14,7 +14,7 @@
  *   GNU General Public License for more details.
  *
  *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, contact Novell, Inc.
+ *   along with this program; if not, contact Canonical, Ltd.
  */
 
 /* Handle subdomain includes, as a straight forward preprocessing phase.
@@ -270,3 +270,63 @@
 	*s = 0;
 	return c;
 }
+
+struct include_stack_t {
+	char *filename;
+	int lineno;
+	struct include_stack_t *next;
+};
+
+struct include_stack_t *include_stack_head = NULL;
+
+static void start_include_position(char *filename)
+{
+	if (current_filename)
+		free(current_filename);
+	current_filename = strdup(filename ? filename : "stdin");
+	current_lineno   = 0;
+}
+
+void push_include_stack(char *filename)
+{
+	struct include_stack_t *include = NULL;
+
+	include = malloc(sizeof(*include));
+	if (!include) {
+		perror("malloc of included file stack tracker");
+		/* failures in this area are non-fatal */
+		return;
+	}
+
+	include->filename  = strdup(current_filename);
+	include->lineno    = current_lineno;
+	include->next      = include_stack_head;
+	include_stack_head = include;
+
+	start_include_position(filename);
+}
+
+void pop_include_stack(void)
+{
+	struct include_stack_t *include = NULL;
+
+	if (!include_stack_head)
+		return;
+
+	include = include_stack_head;
+	include_stack_head = include->next;
+
+	if (current_filename)
+		free(current_filename);
+	current_filename = include->filename;
+	current_lineno   = include->lineno;
+	free(include);
+}
+
+void reset_include_stack(char *filename)
+{
+	while (include_stack_head)
+		pop_include_stack();
+
+	start_include_position(filename);
+}

=== modified file 'parser/parser_include.h'
--- parser/parser_include.h	2009-07-24 07:35:39 +0000
+++ parser/parser_include.h	2010-06-05 01:57:01 +0000
@@ -1,8 +1,8 @@
-/* $Id$ */
-
 /*
  *   Copyright (c) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
  *   NOVELL (All rights reserved)
+ *   Copyright (c) 2010
+ *   Canonical, Ltd.
  *
  *   This program is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
@@ -14,13 +14,15 @@
  *   GNU General Public License for more details.
  *
  *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, contact Novell, Inc.
+ *   along with this program; if not, contact Canonical, Ltd.
  */
 
 #ifndef PARSER_INCLUDE_H
 #define PARSER_INCLUDE_H
 
 extern int preprocess_only;
+extern int current_lineno;
+extern char *current_filename;
 
 extern int add_search_dir(char *dir);
 extern void init_base_dir(void);
@@ -29,4 +31,8 @@
 extern int do_include_preprocessing(char *profilename);
 FILE *search_path(char *filename, char **fullpath);
 
+extern void push_include_stack(char *filename);
+extern void pop_include_stack(void);
+extern void reset_include_stack(char *filename);
+
 #endif

=== modified file 'parser/parser_lex.l'
--- parser/parser_lex.l	2010-03-09 05:49:16 +0000
+++ parser/parser_lex.l	2010-06-05 01:57:01 +0000
@@ -1,8 +1,8 @@
-/* $Id$ */
-
 /*
  *   Copyright (c) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
  *   NOVELL (All rights reserved)
+ *   Copyright (c) 2010
+ *   Canonical, Ltd.
  *
  *   This program is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
@@ -14,7 +14,7 @@
  *   GNU General Public License for more details.
  *
  *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, contact Novell, Inc.
+ *   along with this program; if not, contact Canonical, Ltd.
  */
 
 /* Definitions section */
@@ -49,7 +49,8 @@
 #endif
 #define NPDEBUG(fmt, args...)	/* Do nothing */
 
-int current_lineno = 1;
+int current_lineno     = 0;
+char *current_filename = NULL;
 
 struct ignored_suffix_t {
 	char * text;
@@ -87,7 +88,8 @@
 	}
 
 	if (!include_file)
-		yyerror(_("Could not open '%s'"), fullpath);
+		yyerror(_("Could not open '%s'"),
+                        fullpath ? fullpath: filename);
 
         if (fstat(fileno(include_file), &my_stat))
 		yyerror(_("fstat failed for '%s'"), fullpath);
@@ -95,6 +97,7 @@
         if (S_ISREG(my_stat.st_mode)) {
 		yyin = include_file;
 		PDEBUG("Opened include \"%s\"\n", fullpath);
+		push_include_stack(fullpath);
 		yypush_buffer_state(yy_create_buffer( yyin, YY_BUF_SIZE ));
         }
 
@@ -139,8 +142,9 @@
 				yyerror(_("stat failed for '%s'"), dirent_path);
 			if (S_ISREG(my_stat.st_mode)) {
 				if (!(yyin = fopen(dirent_path,"r")))
-					yyerror(_("Could not open '%s'"), filename);
-				PDEBUG("Opened include \"%s\"\n", filename);
+					yyerror(_("Could not open '%s' in '%s'"), dirent_path, filename);
+				PDEBUG("Opened include \"%s\" in \"%s\"\n", dirent_path, filename);
+				push_include_stack(dirent_path);
 				yypush_buffer_state(yy_create_buffer(yyin, YY_BUF_SIZE));
 			}
 		}
@@ -227,6 +231,8 @@
 }
 
 <<EOF>> {
+	fclose(yyin);
+	pop_include_stack();
 	yypop_buffer_state();
 	if ( !YY_CURRENT_BUFFER ) yyterminate();
 }

=== modified file 'parser/parser_main.c'
--- parser/parser_main.c	2010-01-28 01:20:13 +0000
+++ parser/parser_main.c	2010-06-05 01:47:44 +0000
@@ -4,6 +4,9 @@
  *   Copyright (c) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
  *   NOVELL (All rights reserved)
  *
+ *   Copyright (c) 2010
+ *   Canonical, Ltd. (All rights reserved)
+ *
  *   This program is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
  *   License published by the Free Software Foundation.
@@ -14,7 +17,8 @@
  *   GNU General Public License for more details.
  *
  *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, contact Novell, Inc.
+ *   along with this program; if not, contact Novell, Inc. or Canonical,
+ *   Ltd.
  */
 
 #include <stdio.h>
@@ -85,8 +89,6 @@
 char *profile_namespace = NULL;
 int flag_changehat_version = FLAG_CHANGEHAT_1_5;
 
-extern int current_lineno;
-
 /* per-profile settings */
 int force_complain = 0;
 char *profilename = NULL;
@@ -224,8 +226,10 @@
 	if (conf_quiet || names_only || option == OPTION_REMOVE)
 		return;
 
-	rc = asprintf(&newfmt, _("Warning (%s line %d): %s"),
+	rc = asprintf(&newfmt, _("Warning from %s (%s%sline %d): %s"),
 		      profilename ? profilename : "stdin",
+		      current_filename ? current_filename : "",
+		      current_filename ? " " : "",
 		      current_lineno,
 		      fmt);
 	if (!newfmt)
@@ -258,7 +262,7 @@
 			break;
 		case 'd':
 			debug++;
-			skip_cache = 1;
+			skip_read_cache = 1;
 			break;
 		case 'h':
 			if (!optarg) {
@@ -316,7 +320,7 @@
 			subdomainbase = strndup(optarg, PATH_MAX);
 			break;
 		case 'D':
-			skip_cache = 1;
+			skip_read_cache = 1;
 			if (!optarg) {
 				dump_vars = 1;
 			} else if (strcmp(optarg, "variables") == 0) {
@@ -359,7 +363,7 @@
 			}
 			break;
 		case 'O':
-			skip_cache = 1;
+			skip_read_cache = 1;
 			if (strcmp(optarg, "0") == 0) {
 				dfaflags |= DFA_CONTROL_NO_TREE_NORMAL |
 					DFA_CONTROL_NO_TREE_SIMPLE |
@@ -695,12 +699,13 @@
 	return retval;
 }
 
-void reset_parser(void)
+void reset_parser(char *filename)
 {
 	free_aliases();
 	free_symtabs();
 	free_policies();
 	reset_regex();
+	reset_include_stack(filename);
 }
 
 int process_profile(int option, char *profilename)
@@ -796,7 +801,7 @@
 
 	if (yyin)
 		yyrestart(yyin);
-	reset_parser();
+	reset_parser(profilename);
 
 	retval = yyparse();
 	if (retval != 0)
@@ -812,7 +817,7 @@
 		goto out;
 	}
 
-	retval = post_process_policy();
+	retval = post_process_policy(debug);
   	if (retval != 0) {
   		PERROR(_("%s: Errors found in file. Aborting.\n"), progname);
 		goto out;

=== modified file 'parser/parser_policy.c'
--- parser/parser_policy.c	2009-08-20 15:27:12 +0000
+++ parser/parser_policy.c	2010-03-12 23:26:32 +0000
@@ -4,6 +4,9 @@
  *   Copyright (c) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
  *   NOVELL (All rights reserved)
  *
+ *   Copyright (c) 2010
+ *   Canonical, Ltd. (All rights reserved)
+ *
  *   This program is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
  *   License published by the Free Software Foundation.
@@ -14,7 +17,8 @@
  *   GNU General Public License for more details.
  *
  *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, contact Novell, Inc.
+ *   along with this program; if not, contact Novell, Inc. or Canonical,
+ *   Ltd.
  */
 
 #include <stdio.h>
@@ -664,7 +668,7 @@
 	return ret;
 }
 
-int post_process_policy(void)
+int post_process_policy(int debug_only)
 {
 	int retval = 0;
 
@@ -696,11 +700,13 @@
 		return retval;
 	}
 
-	retval = post_process_regex();
-	if (retval != 0) {
-		PERROR(_("%s: Errors found during regex postprocess.  Aborting.\n"),
-		       progname);
-		return retval;
+	if (!debug_only) {
+		retval = post_process_regex();
+		if (retval != 0) {
+			PERROR(_("%s: Errors found during regex postprocess.  Aborting.\n"),
+			       progname);
+			return retval;
+		}
 	}
 
 	return retval;

=== modified file 'parser/parser_symtab.c'
--- parser/parser_symtab.c	2009-07-24 13:24:53 +0000
+++ parser/parser_symtab.c	2010-03-12 22:41:58 +0000
@@ -33,11 +33,6 @@
 	sd_set,
 };
 
-struct set_value {
-	char *val;
-	struct set_value *next;
-};
-
 struct symtab {
 	char *var_name;
 	enum var_type type;
@@ -288,7 +283,7 @@
 
 /* returns a pointer to the value list, which should be used as the
  * argument to the get_next_set_value() function. */
-void *get_set_var(const char *var)
+struct set_value *get_set_var(const char *var)
 {
 	struct symtab *result;
 	struct set_value *valuelist = NULL;
@@ -321,16 +316,17 @@
 }
 
 /* iterator to walk the list of set values */
-char *get_next_set_value(void **list)
+char *get_next_set_value(struct set_value **list)
 {
-	struct set_value **valuelist = (struct set_value **) list;
+	struct set_value *next;
 	char *ret;
 
-	if (!valuelist || !(*valuelist))
+	if (!list || !(*list))
 		return NULL;
 
-	ret = (*valuelist)->val;
-	(*valuelist) = (*valuelist)->next;
+	ret = (*list)->val;
+	next = (*list)->next;
+	(*list) = next;
 
 	return ret;
 }
@@ -569,7 +565,7 @@
 {
 	int rc = 0;
 	int retval;
-	void *retptr;
+	struct set_value *retptr;
 	struct symtab *a, *b;
 
 	a = new_symtab_entry("blah");

=== modified file 'parser/parser_variable.c'
--- parser/parser_variable.c	2009-07-24 23:47:46 +0000
+++ parser/parser_variable.c	2010-03-12 23:20:22 +0000
@@ -124,7 +124,7 @@
 
 static int expand_entry_variables(struct cod_entry *entry)
 {
-	void *valuelist;
+	struct set_value *valuelist;
 	int ret = TRUE;
 	char *value;
 	struct var_string *split_var;

=== modified file 'parser/parser_yacc.y'
--- parser/parser_yacc.y	2010-02-17 20:21:52 +0000
+++ parser/parser_yacc.y	2010-06-05 01:57:01 +0000
@@ -1,9 +1,9 @@
 %{
-/* $Id$ */
-
 /*
  *   Copyright (c) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
  *   NOVELL (All rights reserved)
+ *   Copyright (c) 2010
+ *   Canonical, Ltd.
  *
  *   This program is free software; you can redistribute it and/or
  *   modify it under the terms of version 2 of the GNU General Public
@@ -15,7 +15,7 @@
  *   GNU General Public License for more details.
  *
  *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, contact Novell, Inc.
+ *   along with this program; if not, contact Canonical, Ltd.
  */
 
 #define YYERROR_VERBOSE 1
@@ -32,6 +32,7 @@
 /* #define DEBUG */
 
 #include "parser.h"
+#include "parser_include.h"
 #include <unistd.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
@@ -63,10 +64,6 @@
 
 #define CAP_TO_MASK(x) (1ull << (x))
 
-/* from lex_config, for nice error messages */
-/* extern char *current_file; */
-extern int current_lineno;
-
 struct value_list {
 	char *value;
 	struct value_list *next;
@@ -1109,10 +1106,15 @@
 	va_end(arg);
 
 	if (profilename) {
-		PERROR(_("AppArmor parser error in %s at line %d: %s\n"),
-		       profilename, current_lineno, buf);
+		PERROR(_("AppArmor parser error for %s%s%s at line %d: %s\n"),
+		       profilename,
+		       current_filename ? " in " : "",
+		       current_filename ? current_filename : "",
+		       current_lineno, buf);
 	} else {
-		PERROR(_("AppArmor parser error, line %d: %s\n"),
+		PERROR(_("AppArmor parser error,%s%s line %d: %s\n"),
+		       current_filename ? " in " : "",
+		       current_filename ? current_filename : "",
 		       current_lineno, buf);
 	}
 

=== modified file 'parser/tst/Makefile'
--- parser/tst/Makefile	2006-12-15 08:10:25 +0000
+++ parser/tst/Makefile	2010-06-05 01:47:44 +0000
@@ -1,8 +1,9 @@
 #
-# $Id$
-#
 PROVE=/usr/bin/prove
 TESTS=simple.pl
+PARSER_DIR=..
+PARSER_BIN=apparmor_parser
+PARSER=$(PARSER_DIR)/$(PARSER_BIN)
 
 ifeq ($(VERBOSE),1)
   PROVE_ARG=-v
@@ -10,9 +11,19 @@
 
 all: tests
 
-.PHONY: tests
-tests: ../apparmor_parser
+.PHONY: tests error_output parser_sanity
+tests: error_output parser_sanity
+
+error_output: $(PARSER)
+	$(PARSER) -S -I errors >/dev/null errors/okay.sd
+	LANG=C $(PARSER) -S -I errors 2>&1 >/dev/null errors/single.sd | \
+		grep -q "AppArmor parser error for errors/single.sd in errors/single.sd at line 3: Could not open 'failure'"
+	LANG=C $(PARSER) -S -I errors 2>&1 >/dev/null errors/double.sd | \
+		grep -q "AppArmor parser error for errors/double.sd in errors/includes/busted at line 67: Could not open 'does-not-exist'"
+	@echo "Error Output: PASS"
+
+parser_sanity: $(PARSER)
 	$(Q)${PROVE} ${PROVE_ARG} ${TESTS}
 
-../apparmor_parser:
-	make -C .. apparmor_parser
+$(PARSER):
+	make -C $(PARSER_DIR) $(PARSER_BIN)

=== modified file 'parser/tst/README'
--- parser/tst/README	2006-06-01 17:02:28 +0000
+++ parser/tst/README	2010-06-05 01:47:44 +0000
@@ -64,5 +64,3 @@
     loop.
 
 Otherwise, the profile is passed on as-is to the subdomain parser.
-
-$Id$ 

=== added directory 'parser/tst/errors'
=== added file 'parser/tst/errors/double.sd'
--- parser/tst/errors/double.sd	1970-01-01 00:00:00 +0000
+++ parser/tst/errors/double.sd	2010-06-05 01:47:44 +0000
@@ -0,0 +1,5 @@
+#
+/does/not/exist {
+  #include <includes/base>
+  #include <includes/busted>
+}

=== added directory 'parser/tst/errors/includes'
=== added file 'parser/tst/errors/includes/base'
--- parser/tst/errors/includes/base	1970-01-01 00:00:00 +0000
+++ parser/tst/errors/includes/base	2010-06-05 01:47:44 +0000
@@ -0,0 +1,81 @@
+# $Id$
+# ------------------------------------------------------------------
+#
+#    Copyright (C) 2002-2005 Novell/SUSE
+#
+#    This program is free software; you can redistribute it and/or
+#    modify it under the terms of version 2 of the GNU General Public
+#    License published by the Free Software Foundation.
+#
+# ------------------------------------------------------------------
+
+
+
+  # (Note that the ldd profile has inlined this file; if you make
+  # modifications here, please consider including them in the ldd
+  # profile as well.)
+
+  # The __canary_death_handler function writes a time-stamped log
+  # message to /dev/log for logging by syslogd. So, /dev/log, timezones,
+  # and localisations of date should be available EVERYWHERE, so
+  # StackGuard, FormatGuard, etc., alerts can be properly logged.
+  /dev/log                       w,
+  /dev/urandom                   r,
+  /etc/locale/**                 r,
+  /etc/localtime                 r,
+  /usr/share/locale/**           r,
+  /usr/share/zoneinfo/**         r,
+
+  /usr/lib64/locale/**           r,
+  /usr/lib64/gconv/*.so          r,
+  /usr/lib64/gconv/gconv-modules*  r,
+  /usr/lib/locale/**             r,
+  /usr/lib/gconv/*.so            r,
+  /usr/lib/gconv/gconv-modules*  r,
+
+  # used by glibc when binding to ephemeral ports
+  /etc/bindresvport.blacklist    r,
+
+  # ld.so.cache and ld are used to load shared libraries; they are best
+  # available everywhere
+  /etc/ld.so.cache               r,
+  # 'px' requires a profile to be available for the transition to
+  # function; without a loaded profile, the kernel will fail the exec.
+  /lib/ld-*.so                   px,
+  /lib64/ld-*.so                 px,
+  /opt/*-linux-uclibc/lib/ld-uClibc*so* px,
+
+  # we might as well allow everything to use common libraries
+  /lib/lib*.so*                  r,
+  /lib/tls/lib*.so*              r,
+  /lib/power4/lib*.so*           r,
+  /lib/power5/lib*.so*           r,
+  /lib/power5+/lib*.so*          r,
+  /lib64/power4/lib*.so*         r,
+  /lib64/power5/lib*.so*         r,
+  /lib64/power5+/lib*.so*        r,
+  /usr/lib/*.so*                 r,
+  /usr/lib/tls/lib*.so*          r,
+  /usr/lib/power4/lib*.so*       r,
+  /usr/lib/power5/lib*.so*       r,
+  /usr/lib/power5+/lib*.so*      r,
+  /lib64/lib*.so*                r,
+  /lib64/tls/lib*.so*            r,
+  /usr/lib64/*.so*               r,
+  /usr/lib64/tls/lib*.so*        r,
+
+  # /dev/null is pretty harmless and frequently used
+  /dev/null                      rw,
+  # as is /dev/zero
+  /dev/zero                      rw,
+
+  # Sometimes used to determine kernel/user interfaces to use
+  /proc/sys/kernel/version       r,
+  # Depending on which glibc routine uses this file, base may not be the
+  # best place -- but many profiles require it, and it is quite harmless.
+  /proc/sys/kernel/ngroups_max   r,
+
+  # glibc's sysconf(3) routine to determine free memory, etc
+  /proc/meminfo                  r,
+  /proc/stat                     r,
+  /proc/cpuinfo                  r,

=== added file 'parser/tst/errors/includes/busted'
--- parser/tst/errors/includes/busted	1970-01-01 00:00:00 +0000
+++ parser/tst/errors/includes/busted	2010-06-05 01:47:44 +0000
@@ -0,0 +1,83 @@
+# $Id$
+# ------------------------------------------------------------------
+#
+#    Copyright (C) 2002-2005 Novell/SUSE
+#
+#    This program is free software; you can redistribute it and/or
+#    modify it under the terms of version 2 of the GNU General Public
+#    License published by the Free Software Foundation.
+#
+# ------------------------------------------------------------------
+
+
+
+  # (Note that the ldd profile has inlined this file; if you make
+  # modifications here, please consider including them in the ldd
+  # profile as well.)
+
+  # The __canary_death_handler function writes a time-stamped log
+  # message to /dev/log for logging by syslogd. So, /dev/log, timezones,
+  # and localisations of date should be available EVERYWHERE, so
+  # StackGuard, FormatGuard, etc., alerts can be properly logged.
+  /dev/log                       w,
+  /dev/urandom                   r,
+  /etc/locale/**                 r,
+  /etc/localtime                 r,
+  /usr/share/locale/**           r,
+  /usr/share/zoneinfo/**         r,
+
+  /usr/lib64/locale/**           r,
+  /usr/lib64/gconv/*.so          r,
+  /usr/lib64/gconv/gconv-modules*  r,
+  /usr/lib/locale/**             r,
+  /usr/lib/gconv/*.so            r,
+  /usr/lib/gconv/gconv-modules*  r,
+
+  # used by glibc when binding to ephemeral ports
+  /etc/bindresvport.blacklist    r,
+
+  # ld.so.cache and ld are used to load shared libraries; they are best
+  # available everywhere
+  /etc/ld.so.cache               r,
+  # 'px' requires a profile to be available for the transition to
+  # function; without a loaded profile, the kernel will fail the exec.
+  /lib/ld-*.so                   px,
+  /lib64/ld-*.so                 px,
+  /opt/*-linux-uclibc/lib/ld-uClibc*so* px,
+
+  # we might as well allow everything to use common libraries
+  /lib/lib*.so*                  r,
+  /lib/tls/lib*.so*              r,
+  /lib/power4/lib*.so*           r,
+  /lib/power5/lib*.so*           r,
+  /lib/power5+/lib*.so*          r,
+  /lib64/power4/lib*.so*         r,
+  /lib64/power5/lib*.so*         r,
+  /lib64/power5+/lib*.so*        r,
+  /usr/lib/*.so*                 r,
+  /usr/lib/tls/lib*.so*          r,
+  /usr/lib/power4/lib*.so*       r,
+  /usr/lib/power5/lib*.so*       r,
+  /usr/lib/power5+/lib*.so*      r,
+  /lib64/lib*.so*                r,
+  /lib64/tls/lib*.so*            r,
+  /usr/lib64/*.so*               r,
+  /usr/lib64/tls/lib*.so*        r,
+
+  #include <does-not-exist>
+
+  # /dev/null is pretty harmless and frequently used
+  /dev/null                      rw,
+  # as is /dev/zero
+  /dev/zero                      rw,
+
+  # Sometimes used to determine kernel/user interfaces to use
+  /proc/sys/kernel/version       r,
+  # Depending on which glibc routine uses this file, base may not be the
+  # best place -- but many profiles require it, and it is quite harmless.
+  /proc/sys/kernel/ngroups_max   r,
+
+  # glibc's sysconf(3) routine to determine free memory, etc
+  /proc/meminfo                  r,
+  /proc/stat                     r,
+  /proc/cpuinfo                  r,

=== added file 'parser/tst/errors/okay.sd'
--- parser/tst/errors/okay.sd	1970-01-01 00:00:00 +0000
+++ parser/tst/errors/okay.sd	2010-06-05 01:47:44 +0000
@@ -0,0 +1,4 @@
+#
+/does/not/exist {
+  #include <includes/base>
+}

=== added file 'parser/tst/errors/single.sd'
--- parser/tst/errors/single.sd	1970-01-01 00:00:00 +0000
+++ parser/tst/errors/single.sd	2010-06-05 01:47:44 +0000
@@ -0,0 +1,7 @@
+#
+#
+#include <failure>
+#
+/does/not/exist {
+  #include <includes/base>
+}

=== modified file 'profiles/apparmor.d/abstractions/base'
--- profiles/apparmor.d/abstractions/base	2010-01-03 21:16:38 +0000
+++ profiles/apparmor.d/abstractions/base	2010-06-05 00:43:11 +0000
@@ -85,6 +85,9 @@
   # some applications will display license information
   /usr/share/common-licenses/**  r,
 
+  # glibc statvfs
+  @{PROC}/filesystems            r,
+
   # Workaround https://launchpad.net/bugs/359338 until upstream handles stacked
   # filesystems generally. This does not appreciably decrease security with
   # Ubuntu profiles because the user is expected to have access to files owned

=== added file 'profiles/apparmor.d/abstractions/dbus-session'
--- profiles/apparmor.d/abstractions/dbus-session	1970-01-01 00:00:00 +0000
+++ profiles/apparmor.d/abstractions/dbus-session	2010-04-19 17:38:17 +0000
@@ -0,0 +1,14 @@
+# vim:syntax=apparmor
+# $Id$
+# ------------------------------------------------------------------
+#
+#    Copyright (C) 2010 Canonical Ltd.
+#
+#    This program is free software; you can redistribute it and/or
+#    modify it under the terms of version 2 of the GNU General Public
+#    License published by the Free Software Foundation.
+#
+# ------------------------------------------------------------------
+
+  #include <abstractions/dbus>
+  /usr/bin/dbus-launch Uxr,

=== modified file 'profiles/apparmor.d/abstractions/fonts'
--- profiles/apparmor.d/abstractions/fonts	2009-11-04 20:25:42 +0000
+++ profiles/apparmor.d/abstractions/fonts	2010-06-05 00:44:30 +0000
@@ -15,6 +15,7 @@
 
   /usr/lib/xorg/modules/fonts/**.so*    mr,
 
+  /usr/share/fonts/                     r,
   /usr/share/fonts/**                   r,
 
   /etc/fonts/**                         r,

=== modified file 'profiles/apparmor.d/abstractions/freedesktop.org'
--- profiles/apparmor.d/abstractions/freedesktop.org	2009-11-04 20:25:42 +0000
+++ profiles/apparmor.d/abstractions/freedesktop.org	2010-06-05 00:44:30 +0000
@@ -27,3 +27,7 @@
   @{HOME}/.icons/                 r,
   @{HOME}/.recently-used.xbel*    rw,
   @{HOME}/.config/user-dirs.dirs  r,
+  @{HOME}/.local/share/icons/     r,
+  @{HOME}/.local/share/icons/**   r,
+  @{HOME}/.local/share/mime/      r,
+  @{HOME}/.local/share/mime/**    r,

=== modified file 'profiles/apparmor.d/abstractions/nameservice'
--- profiles/apparmor.d/abstractions/nameservice	2009-11-04 20:25:42 +0000
+++ profiles/apparmor.d/abstractions/nameservice	2010-06-05 00:44:59 +0000
@@ -77,3 +77,5 @@
   network inet  dgram,
   network inet6 dgram,
 
+  # interface details
+  @{PROC}/*/net/route r,

=== modified file 'profiles/apparmor.d/abstractions/php5'
--- profiles/apparmor.d/abstractions/php5	2010-01-03 21:16:38 +0000
+++ profiles/apparmor.d/abstractions/php5	2010-03-30 17:34:32 +0000
@@ -2,7 +2,7 @@
 # ------------------------------------------------------------------
 #
 #    Copyright (C) 2002-2006 Novell/SUSE
-#    Copyright (C) 2009 Canonical, Ltd.
+#    Copyright (C) 2009-2010 Canonical Ltd.
 #
 #    This program is free software; you can redistribute it and/or
 #    modify it under the terms of version 2 of the GNU General Public
@@ -11,13 +11,13 @@
 # ------------------------------------------------------------------
 
   # shared snippets for config files
-  /etc/php5/{conf.d,apache2,cli,fastcgi}/ r,
-  /etc/php5/{conf.d,apache2,cli,fastcgi}/*.ini r,
+  /etc/php5/{conf.d,apache2,cli,fastcgi,cgi}/ r,
+  /etc/php5/{conf.d,apache2,cli,fastcgi,cgi}/*.ini r,
 
   # Xlibs
   /usr/X11R6/lib{,32,64}/lib*.so* mr,
   # php extensions
-  /usr/lib{64,}/php5/{libexec,extensions}/*.so mr,
+  /usr/lib{64,}/php5/*/*.so mr,
 
   # php5 session mmap socket
   /var/lib/php5/session_mm_* rwlk,

=== modified file 'profiles/apparmor.d/abstractions/samba'
--- profiles/apparmor.d/abstractions/samba	2009-11-04 20:25:42 +0000
+++ profiles/apparmor.d/abstractions/samba	2010-03-25 23:13:00 +0000
@@ -2,7 +2,7 @@
 # $Id$
 # ------------------------------------------------------------------
 #
-#    Copyright (C) 2009 Canonical Ltd.
+#    Copyright (C) 2009-2010 Canonical Ltd.
 #
 #    This program is free software; you can redistribute it and/or
 #    modify it under the terms of version 2 of the GNU General Public
@@ -12,7 +12,7 @@
 
   /etc/samba/smb.conf r,
   /usr/share/samba/*.dat r,
-  /var/lib/samba/**.tdb rw,
+  /var/lib/samba/**.tdb rwk,
   /var/log/samba/cores/* w,
   /var/log/samba/log.* w,
   /var/run/samba/*.tdb rw,

=== modified file 'profiles/apparmor.d/abstractions/user-tmp'
--- profiles/apparmor.d/abstractions/user-tmp	2009-11-04 20:25:42 +0000
+++ profiles/apparmor.d/abstractions/user-tmp	2010-05-12 08:52:23 +0000
@@ -2,7 +2,7 @@
 # ------------------------------------------------------------------
 #
 #    Copyright (C) 2002-2009 Novell/SUSE
-#    Copyright (C) 2009 Canonical Ltd.
+#    Copyright (C) 2009-2010 Canonical Ltd.
 #
 #    This program is free software; you can redistribute it and/or
 #    modify it under the terms of version 2 of the GNU General Public
@@ -11,11 +11,11 @@
 # ------------------------------------------------------------------
 
   # per-user tmp directories
-  @{HOME}/tmp/**  rwkl,
-  @{HOME}/tmp/    rw,
+  owner @{HOME}/tmp/**  rwkl,
+  owner @{HOME}/tmp/    rw,
 
   # global tmp directories
-  /var/tmp/**     rwkl,
-  /var/tmp/       rw,
-  /tmp/**         rwkl,
-  /tmp/           rw,
+  owner /var/tmp/**     rwkl,
+  owner /var/tmp/       rw,
+  owner /tmp/**         rwkl,
+  owner /tmp/           rw,

=== modified file 'tests/regression/subdomain/prologue.inc'
--- tests/regression/subdomain/prologue.inc	2010-02-07 07:04:57 +0000
+++ tests/regression/subdomain/prologue.inc	2010-04-27 09:37:30 +0000
@@ -93,8 +93,10 @@
 
 	while [ -h ${link} ]
 	do
-		if [ -x /usr/bin/readlink ] ; then 
-			target=$(/usr/bin/readlink ${link})
+		if [ -x /usr/bin/readlink ] ; then
+			target=$(/usr/bin/readlink -f ${link})
+		elif [ -x /bin/readlink ] ; then
+			target=$(/bin/readlink -f ${link})
 		else 
 			# I'm sure there's a more perlish way to do this
 			target=$( perl -e "printf (\"%s\n\", readlink(\"${link}\"));") 

=== modified file 'tests/stress/parser/stress.rb'
--- tests/stress/parser/stress.rb	2008-11-26 22:16:48 +0000
+++ tests/stress/parser/stress.rb	2010-03-15 18:31:38 +0000
@@ -14,10 +14,27 @@
   return sprintf("%0#{len}x", rand(2 ** (4 * len)))
 end
 
+def get_random_regex()
+  case rand(10)
+    when 0..3
+      return "{#{get_random_name(rand(8) + 2)},#{get_random_name(rand(8) + 2)},#{get_random_name(rand(8) + 2)}}"
+    when 4..5
+      return "[#{get_random_name(rand(5) + 1)}]"
+    when 6..7
+      return "*"
+    when 8..9
+      return "**"
+  end
+end
+
 def get_random_path()
   out = ""
-  0.upto(rand(20)) do
-    out = "#{out}/#{get_random_name(4)}"
+  0.upto(rand(20) + 2) do
+    if rand(4) == 0
+      out = "#{out}/#{get_random_regex}"
+    else
+      out = "#{out}/#{get_random_name(rand(10) + 4)}"
+    end
   end
   return out
 end
@@ -83,7 +100,10 @@
     "mknod",
     "lease",
     "audit_write",
-    "audit_control"
+    "audit_control",
+    "setfcap",
+    "mac_override",
+    "mac_admin"
   ]
 
   def initialize()
@@ -95,6 +115,93 @@
   end
 end
 
+class NetRule < Rule
+  # XXX Fill me in
+end
+
+class RlimitRule < Rule
+  RLIMIT_LIST = [
+#"cpu",		# cpu rlimit not supported
+    "fsize",
+    "data",
+    "stack",
+    "core",
+    "rss",
+    "nofile",
+    "ofile",
+    "as",
+    "nproc",
+    "memlock",
+    "locks",
+    "sigpending",
+    "msgqueue",
+    "nice",
+    "rtprio"
+  ]
+
+  def initialize()
+    @rlimit = RLIMIT_LIST[rand(RLIMIT_LIST.length)]
+    if rand(20) == 0
+      @limit = "infinity"
+    elsif @rlimit == "nice"
+      @limit = rand(40) - 20
+    else
+      @limit = rand(2 ** 31)
+    end
+  end
+
+  def to_s
+    return "  set rlimit #{@rlimit} <= #{@limit},"
+  end
+end
+
+class Flags
+  FLAG_LIST = [
+    "complain",
+    "audit",
+    "chroot_relative",
+    "namespace_relative",
+    "mediate_deleted",
+    "delegate_deleted",
+    "attach_disconnected",
+    "no_attach_disconnected",
+    "chroot_attach",
+    "chroot_no_attach"
+  ]
+
+  FLAG_CONFLICTS = [
+    ["chroot_relative", "namespace_relative"],
+    ["mediate_deleted", "delegate_deleted"],
+    ["attach_disconnected", "no_attach_disconnected"],
+    ["chroot_attach", "chroot_no_attach"]
+  ]
+
+  def initialize()
+    @flags = []
+    if rand(2) == 1
+      return
+    end
+
+    0.upto(4 - Math.log(rand(32) + 1).to_int) do |x|
+      @flags << FLAG_LIST[rand(FLAG_LIST.length)]
+    end
+
+    FLAG_CONFLICTS.each do |c|
+      if @flags.include?(c[0]) and @flags.include?(c[1])
+        @flags.delete(c[rand(2)])
+      end
+    end
+  end
+
+  def to_s
+    if @flags.empty?
+      return ""
+    end
+    out = @flags.join(",")
+    return "flags=(#{out})"
+  end
+end
+
 def prefix_to_s(name)
   out = []
   out << "#"
@@ -112,16 +219,19 @@
     @rvalue = get_random_name()
     @name = "/does/not/exist/#{@rvalue}"
     @rules = []
+    @flags = Flags.new()
   end
 
   def generate_rules
-    @rules << FileRule.new(@name, "rm")
+    @rules << FileRule.new(@name, "rm").to_s
     0.upto(rand($max_rules - $min_rules) + $min_rules) do |x|
       case rand(100)
-        when 0..19
-          @rules << CapRule.new
-        when 19..100
-          @rules << FileRule.new
+        when 0..14
+          @rules << CapRule.new.to_s
+        when 15..24
+          @rules << RlimitRule.new.to_s
+        when 25..100
+          @rules << FileRule.new.to_s
       end
     end
   end
@@ -132,10 +242,10 @@
     out << "# profile for #{@name}"
     out << "# generated by #{__FILE__} #{$my_version}"
     out << "#"
-    out << "#{@name} {"
+    out << "#{@name} #{@flags} {"
     out << "  #include <abstractions/base>"
     out << ""
-    @rules.each { |r| out << r.to_s }
+    @rules.sort.each { |r| out << "  #{r}" }
     out << "}"
     out << ""
   end

=== modified file 'utils/SubDomain.pm'
--- utils/SubDomain.pm	2010-03-10 23:30:06 +0000
+++ utils/SubDomain.pm	2010-03-26 13:51:21 +0000
@@ -6612,10 +6612,14 @@
     LibAppArmor::free_record($event);
 
     #map new c and d to w as logprof doesn't support them yet
-    $rmask =~ s/c/w/g;
-    $rmask =~ s/d/w/g;
-    $dmask =~ s/c/w/g;
-    $dmask =~ s/d/w/g;
+    if ($rmask) {
+        $rmask =~ s/c/w/g;
+        $rmask =~ s/d/w/g;
+    }
+    if ($dmask) {
+        $dmask =~ s/c/w/g;
+        $dmask =~ s/d/w/g;
+    }
 
     if ($rmask && !validate_log_mode(hide_log_mode($rmask))) {
         fatal_error(sprintf(gettext('Log contains unknown mode %s.'),

=== modified file 'utils/apparmor_notify'
--- utils/apparmor_notify	2010-03-10 16:11:26 +0000
+++ utils/apparmor_notify	2010-05-27 14:08:12 +0000
@@ -30,8 +30,7 @@
 require Time::Local;
 require File::Basename;
 
-use vars qw($opt_p $opt_s $opt_l $opt_h $opt_v $opt_d $opt_w);
-use Getopt::Std;
+use Getopt::Long;
 
 my %prefs;
 my $conf = "/etc/apparmor/notify.conf";
@@ -67,7 +66,6 @@
 $ENV{SHELL} = "/bin/sh";
 defined($ENV{IFS}) and $ENV{IFS} = ' \t\n';
 
-print $0 . "\n";
 my $prog = File::Basename::basename($0);
 
 if ($prog !~ /^[a-zA-Z0-9_\-]+$/) {
@@ -75,32 +73,66 @@
     exitscript(1);
 }
 
-my $logfile = "/var/log/kern.log";
--e "/var/run/auditd.pid" and $logfile = "/var/log/audit/audit.log";
-
 $> == $< or die "Cannot be suid\n";
 $) == $( or die "Cannot be sgid\n";
 
 my $login;
+our $orig_euid = $>;
 
-getopts('dhlpvs:w:');
+my $opt_d = '';
+my $opt_h = '';
+my $opt_l = '';
+my $opt_p = '';
+my $opt_v = '';
+my $opt_f = '';
+my $opt_s = 0;
+my $opt_u = '';
+my $opt_w = 0;
+GetOptions(
+    'debug|d'        => \$opt_d,
+    'help|h'         => \$opt_h,
+    'since-last|l'   => \$opt_l,
+    'poll|p'         => \$opt_p,
+    'verbose|v'      => \$opt_v,
+    'file|f=s'       => \$opt_f,
+    'since-days|s=n' => \$opt_s,
+    'user|u=s'       => \$opt_u,
+    'wait|w=n'       => \$opt_w,
+);
 if ($opt_h) {
     usage;
     exitscript(0);
 }
 
+# monitor file specified with -f, else use audit.log if auditd is running,
+# otherwise kern.log
+our $logfile = "/var/log/kern.log";
+if ($opt_f) {
+    -f $opt_f or die "'$opt_f' does not exist. Aborting\n";
+    $logfile = $opt_f;
+} else {
+    -e "/var/run/auditd.pid" and $logfile = "/var/log/audit/audit.log";
+}
+
+-r $logfile or die "Cannot read '$logfile'\n";
+our $logfile_inode = get_logfile_inode($logfile);
+our $logfile_size = get_logfile_size($logfile);
 open (LOGFILE, "<$logfile") or die "Could not open '$logfile'\n";
 # Drop priviliges, if running as root
 if ($< == 0) {
     $login = "root";
     if (defined($ENV{SUDO_UID}) and defined($ENV{SUDO_GID})) {
         POSIX::setgid($ENV{SUDO_GID}) or _error("Could not change gid");
-        POSIX::setuid($ENV{SUDO_UID}) or _error("Could not change uid");
+        $> = $ENV{SUDO_UID} or _error("Could not change euid");
         defined($ENV{SUDO_USER}) and $login = $ENV{SUDO_USER};
     } else {
+        my $drop_to = $nobody_user;
+        if ($opt_u) {
+            $drop_to = $opt_u;
+        }
         # nobody/nogroup
-        POSIX::setgid(scalar(getpwnam($nobody_group))) or _error("Could not change gid to '$nobody_group'");
-        POSIX::setuid(scalar(getpwnam($nobody_user))) or _error("Could not change uid to '$nobody_user'");
+        POSIX::setgid(scalar(getgrnam($nobody_group))) or _error("Could not change gid to '$nobody_group'");
+        $> = scalar(getpwnam($drop_to)) or _error("Could not change euid to '$drop_to'");
     }
 } else {
     $login = getlogin();
@@ -111,7 +143,7 @@
     readconf($conf);
     if (defined($prefs{use_group})) {
         my ($name, $passwd, $gid, $members) = getgrnam($prefs{use_group});
-        if (not defined($members) or not defined($login) or not grep { $_ eq $login } split(/ /, $members)) {
+        if (not defined($members) or not defined($login) or (not grep { $_ eq $login } split(/ /, $members) and $login ne "root")) {
             _error("'$login' must be in '$prefs{use_group}' group. Aborting");
         }
     }
@@ -220,7 +252,6 @@
     defined($name) and $formatted .= "Name: $name\n";
     defined($denied) and $formatted .= "Denied: $denied\n";
     defined($family) and defined ($sock_type) and $formatted .= "Family: $family\nSocket type: $sock_type\n";
-    #defined($date) and $since > 0 and $formatted .= "Date: ". scalar(localtime($date)) ."\n";
     $formatted .= "Logfile: $logfile\n";
 
     return $formatted;
@@ -259,6 +290,26 @@
     close(PS);
 }
 
+sub send_message {
+    my $msg = $_[0];
+
+    my $pid = fork();
+    if ($pid == 0) { 	# child
+        # notify-send needs $< to be the unprivileged user
+        $< = $>;
+
+        # 'system' uses execvp() so no shell metacharacters here.
+        # $notify_exe is an absolute path so execvp won't search PATH.
+        system "$notify_exe", "-i", "gtk-dialog-warning", "-u", "critical", "--", "AppArmor Message", "$msg";
+        my $exit_code = $? >> 8;
+        exit($exit_code);
+    }
+
+    # parent
+    waitpid($pid, 0);
+    return $?;
+}
+
 sub do_notify {
     my %seen;
     my $seconds = 5;
@@ -273,7 +324,7 @@
         umask 0;
         open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
         open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";
-        open STDERR, '>/dev/null' or die "Can't write to /dev/null: $!";
+        #open STDERR, '>/dev/null' or die "Can't write to /dev/null: $!";
         my $pid = fork();
         exit if $pid;
         die "Couldn't fork: $!" unless defined($pid);
@@ -293,12 +344,24 @@
     my $count = 0;
     my $footer = "For more information, please see:\n$url";
     my $first_run = 1;
-    my $since = $now - (int($opt_s) * 60 * 60 * 24);
+    my $since = $now;
+    if ($opt_s and int($opt_s) > 0) {
+       $since = $since - (int($opt_s) * 60 * 60 * 24);
+    }
     for (my $i=0; $time_to_die == 0; $i++) {
+        if ($logfile_inode != get_logfile_inode($logfile)) {
+            _warn("$logfile changed inodes, reopening");
+            reopen_logfile();
+        } elsif (get_logfile_size($logfile) < $logfile_size) {
+            _warn("$logfile is smaller, reopening");
+            reopen_logfile();
+        }
         while(my $msg = <LOGFILE>) {
             my @attrib;
-            if ($first_run == 1 and $opt_s) {
-                @attrib = parse_message($msg, $since);
+            if ($first_run == 1) {
+                if ($since != $now) {
+                    @attrib = parse_message($msg, $since);
+                }
             } else {
                 @attrib = parse_message($msg);
             }
@@ -340,12 +403,9 @@
 
             $m .= $footer;
 
-	    # 'system' uses execvp() so no shell metacharacters here.
-            # $notify_exe is an absolute path so execvp won't search PATH.
-            system "$notify_exe", "-i", "gtk-dialog-warning", "-u", "critical", "--", "AppArmor Message", "$m";
-            my $exit_code = $? >> 8;
-            if ($exit_code != 0) {
-                _warn("'$notify_exe' exited with '$exit_code'");
+            my $rc = send_message($m);
+            if ($rc != 0) {
+                _warn("'$notify_exe' exited with error '$rc'");
                 $time_to_die = 1;
                 last;
             }
@@ -356,7 +416,7 @@
 
         if ($first_run) {
             if ($count > 0) {
-                my $m = "$logfile contains $count existing denied message";
+                my $m = "$logfile contains $count denied message";
                 $count > 1 and $m .= "s";
                 if ($opt_s) {
                     $m .= " in the last ";
@@ -368,7 +428,7 @@
                 }
                 $m .= ". ";
                 $m .= $footer;
-                system "$notify_exe", "-i", "gtk-dialog-warning", "-u", "critical", "--", "AppArmor Message", "$m";
+                send_message($m);
             }
             $first_run = 0;
         }
@@ -390,6 +450,9 @@
 }
 
 sub show_since {
+    my %msg_hash;
+    my %last_date;
+    my @msg_list;
     my $count = 0;
     while(my $msg = <LOGFILE>) {
         my @attrib = parse_message($msg, $_[0]);
@@ -397,10 +460,31 @@
 
         my $m = format_message(@attrib);
         $m ne "" or next;
-
-        $opt_v and print "$m\n";
+        my $date = $attrib[6];
+        if ($opt_v) {
+            if (exists($msg_hash{$m})) {
+                $msg_hash{$m}++;
+                defined($date) and $last_date{$m} = scalar(localtime($date));
+            } else {
+                $msg_hash{$m} = 1;
+                push(@msg_list, $m);
+            }
+        }
         $count++;
     }
+    if ($opt_v) {
+        foreach my $m (@msg_list) {
+            print "$m";
+            if ($msg_hash{$m} gt 1) {
+                print "($msg_hash{$m} found";
+                if (exists($last_date{$m})) {
+                    print ", most recent from '$last_date{$m}'";
+                }
+                print ")\n";
+            }
+            print "\n";
+        }
+    }
     return $count;
 }
 
@@ -452,19 +536,63 @@
 sub usage {
     my $s = <<'EOF';
 USAGE: apparmor_notify [OPTIONS]
+
 Display AppArmor notifications or messages for DENIED entries.
 
 OPTIONS:
-  -p		poll AppArmor logs and display notifications
-  -l		display stats since last login
-  -s NUM	show stats for last NUM days (can be used alone or with -p)
-  -v		show messages with stats
-  -h		display this help
-  -w NUM	wait NUM seconds before displaying notifications (with -p)
+  -p, --poll			poll AppArmor logs and display notifications
+  -f FILE, --file=FILE		search FILE for AppArmor messages
+  -l, --since-last		display stats since last login
+  -s NUM, --since-days=NUM	show stats for last NUM days (can be used alone
+				or with -p)
+  -v, --verbose			show messages with stats
+  -h, --help			display this help
+  -u USER, --user=USER		user to drop privileges to when not using sudo
+  -w NUM, --wait=NUM		wait NUM seconds before displaying
+				notifications (with -p)
 EOF
     print $s;
 }
 
+sub reopen_logfile {
+    # reopen the logfile, temporarily switching back to starting euid for
+    # file permissions.
+    close(LOGFILE);
+
+    my $old_euid = $>;
+    my $change_euid = 0;
+    if ($> != $<) {
+        _debug("raising privileges to '$orig_euid' in reopen_logfile()");
+        $change_euid = 1;
+        $> = $orig_euid;
+        $> == $orig_euid or die "Could not raise privileges\n";
+    }
+
+    $logfile_inode = get_logfile_inode($logfile);
+    $logfile_size = get_logfile_size($logfile);
+    open (LOGFILE, "<$logfile") or die "Could not open '$logfile'\n";
+
+    if ($change_euid) {
+        _debug("dropping privileges to '$old_euid' in reopen_logfile()");
+        $> = $old_euid;
+        $> == $old_euid or die "Could not drop privileges\n";
+    }
+}
+
+sub get_logfile_size {
+    my $fn = $_[0];
+    my $size;
+    defined(($size = (stat($fn))[7])) or (sleep(10) and defined(($size = (stat($fn))[7])) or die "'$fn' disappeared. Aborting\n");
+    return $size;
+}
+
+sub get_logfile_inode {
+    my $fn = $_[0];
+    my $inode;
+    defined(($inode = (stat($fn))[1])) or (sleep(10) and defined(($inode = (stat($fn))[1])) or die "'$fn' disappeared. Aborting\n");
+    return $inode;
+}
+
 #
 # end Subroutines
 #

=== modified file 'utils/apparmor_notify.pod'
--- utils/apparmor_notify.pod	2010-02-12 16:25:02 +0000
+++ utils/apparmor_notify.pod	2010-05-12 08:46:22 +0000
@@ -40,24 +40,37 @@
 
 =over 4
 
-=item -p
+=item -p, --poll
 
 poll AppArmor logs and display desktop notifications. Can be used with '-s'
 option to display a summary on startup.
 
-=item -l
+=item -f FILE, --file=FILE
+
+search FILE for AppArmor messages
+
+=item -l, --since-last
 
 show summary since last login.
 
-=item -s NUM
+=item -s NUM, --since-days=NUM
 
 show summary for last NUM of days.
 
-=item -v
+=item -u USER, --user=USER
+
+user to drop privileges to when running privileged. This has no effect when
+running under sudo.
+
+=item -w NUM, --wait=NUM
+
+wait NUM seconds before displaying notifications (for use with -p)
+
+=item -v, --verbose
 
 show messages with summaries.
 
-=item -h
+=item -h, --help
 
 displays a short usage statement.
 

